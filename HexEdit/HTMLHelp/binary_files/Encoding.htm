<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">

<html>

<!--(==============================================================)-->
<!--(Document created with RoboEditor. )============================-->
<!--(==============================================================)-->

<head>

<title>Encoding Binary Data</title>

<!--(Meta)==========================================================-->

<meta http-equiv=content-type content="text/html; charset=windows-1252">
<meta name=date content="08 4, 2002 1:07:02 AM">
<meta name=generator content="RoboHELP by eHelp Corporation - www.ehelp.com">
<meta name=generator-major-version content=0.1>
<meta name=generator-minor-version content=1>
<meta name=filetype content=kadov>
<meta name=filetype-version content=1>
<meta name=page-count content=1>
<meta name=layout-height content=747>
<meta name=layout-width content=1156>


<!--(Links)=========================================================-->

<link rel="StyleSheet" href="..\Hexedit.css">



</head>

<!--(Body)==========================================================-->


<body>

<h2><font style="font-family: Arial;"
			face=Arial>Encoding Binary Data</font></h2>

<p>&nbsp;</p>

<p>Sometimes it is necessary to encode binary data in the form of text. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This is 
 mainly done to enable transmission over channels that cannot handle binary 
 data.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>Early UNIX computers used serial (RS232) connections and modems to communicate. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->These were 
 usually just connected up to terminal ports which handled certain control 
 characters (such as Ctrl+D) in special ways which were beyond the control 
 of the application software (either in hardware or the terminal device 
 driver). <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Further, 
 if a simple 3 wire connection was used then hardware signalling could 
 not be used and control characters (Ctrl+S and Ctrl+Q) were needed for 
 in-band signalling to avoid buffer overruns. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Also 
 some RS232 connections only handled 7-bit ASCII values, and hence you 
 could not send a byte value with the high bit on.</p>

<p>&nbsp;</p>

<p>To copy a binary file between UNIX systems uuencode and uudecode were 
 created. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->(The 
 &quot;uu&quot; basically signifies that they were part of a suite of utilities 
 all starting with uu and used for UNIX to UNIX communication.) <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Each 
 line of text has a count, and there are also header and trailer lines. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This encoding 
 stored 3 binary bytes in 4 printable ASCII characters. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Since 
 these files were commonly transmitted using timed telephone calls or over 
 networks which charged on the amount of data sent then it was important 
 to limit the size increase as much as possible. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Files 
 were typically compressed (using the UNIX compress utility) before being 
 uuencoded.</p>

<p>&nbsp;</p>

<p>Similarly as email between different systems became popular, people 
 wanted to attach binary files to their email, but many systems could not 
 receive binary files. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->MIME 
 was invented to handle this. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This 
 simply converts groups of 6 bits to a base 64 digit, which again stores 
 3 binary bytes in 4 text characters.</p>

<p>&nbsp;</p>

<p>Note that HexEdit does not (yet) support the import and export of uuencoded 
 and MIME files.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>Assembler programmers and electronic engineers also found a need to 
 encode binary data for transmission. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->In 
 this case, the purpose was to send object code (and binary data) to hardware 
 devices such as hardware testing systems, EPROM programmers, in-circuit 
 emulators etc. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Two 
 very similar formats were invented: Motorola's S record format and Intel's 
 Hex format.</p>

<p>&nbsp;</p>

<p>In both of these formats several (typically 16 or 32) bytes of data 
 are each stored as 2 hex characters each in a line of text, along with 
 a checksum for the line and a few other things. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Hence 
 these formats more than double the size of a binary file when encoded 
 as text. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->However 
 this size doubling is not so important as for uuencode/MIME since there 
 are typically no costs associated with transmission apart from the extra 
 time taken.</p>

<p>&nbsp;</p>

<p>Both of these formats contain an address on each line of text which 
 is the address that the first data byte should be loaded. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Motorola 
 supports 3 &quot;record&quot; formats called S1, S2 and S3, which use 
 16, 24 and 32 bit addresses respectively. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Intel 
 Hex only supports 16 bits addresses. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 receiving device uses this address to determine where the data is to be 
 loaded. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->This 
 could be used, for example, to store object code in one part of the memory 
 map and data in another. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Note 
 that HexEdit 2.6 now supports importing data at discontiguous addresses 
 (in previous versions of HexEdit addresses of data records had to be consecutive).</p>

<p>&nbsp;</p>

<p>Error checking in both formats is accomplished using a checksum for 
 each line. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 Motorola S format also supports a record count as the last record, which 
 will detect if a whole line of text went missing. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->When 
 HexEdit reads these types of files it validates all checksums (and the 
 Motorola S record count), and checks that all lines are for contiguous 
 pieces of memory.</p>

<p>&nbsp;</p>

<p><span style="font-weight: bold;">Next topic:</span> <a HREF="Error_Checking.htm">Error 
 Detection</a></p>

<p>&nbsp;</p>

</body>

</html>
